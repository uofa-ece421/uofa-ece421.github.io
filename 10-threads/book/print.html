<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Concurrency in Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="closures.html"><strong aria-hidden="true">1.</strong> Closures</a></li><li class="chapter-item expanded "><a href="cvp.html"><strong aria-hidden="true">2.</strong> Concurrency vs Parallelism</a></li><li class="chapter-item expanded "><a href="threads.html"><strong aria-hidden="true">3.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="channels.html"><strong aria-hidden="true">4.</strong> Channels</a></li><li class="chapter-item expanded "><a href="request-response.html"><strong aria-hidden="true">5.</strong> Request/Response</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Concurrency in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<p><em>Closures</em> are anonymous functions, sometimes called <em>lambda</em> functions, that
can be saved in a variable or passed as arguments to other functions.</p>
<pre><pre class="playground"><code class="language-rust">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }

fn main() {
    let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
    let add_one_v3 = |x|             { x + 1 };
    let add_one_v4 = |x|               x + 1  ;

    assert_eq!(add_one_v1(5), add_one_v2(5));
    assert_eq!(add_one_v3(5), add_one_v4(5));

    let ptr: fn(u32) -&gt; u32 = add_one_v1;
    let closure: fn(u32) -&gt; u32 = |x| x + 1;

    assert_eq!(ptr(10), closure(10));
}</code></pre></pre>
<p>Functions that expect closures as arguments implement the <code>FnOnce</code> Trait</p>
<ul>
<li><code>FnOnce</code> as in <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else">Option::unwrap_or_else</a></li>
<li><code>FnMut</code> is a subtrait of <code>FnOnce</code>, as in <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map">Iterator::map</a></li>
<li><code>Fn</code> is a subtrait of both <code>FnOnce</code> and <code>FnMut</code>, and is different that a function pointer <code>fn</code> (which is a primitive type).</li>
</ul>
<p>Closures are typically short, simple and relevant to a specific context, compared
to functions that are usually more general purpose or context insensitive.</p>
<h3 id="borrows-and-moves"><a class="header" href="#borrows-and-moves">Borrows and Moves</a></h3>
<p>Closures can capture values from their environment in three ways:
immutable borrow, mutable borrow, and move. This is similar to the way function
parameters work, although it now applies to the closure body. The compiler can
usually infer which type of capture to use.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {:?}&quot;, list);

    let only_borrows = || println!(&quot;From closure: {:?}&quot;, list);

    println!(&quot;Before calling closure: {:?}&quot;, list);
    only_borrows();

    let mut borrows_mutably = || list.push(4);

    // println!(&quot;both a mutable and immutable borrow: {:?}&quot;, list);
    borrows_mutably();

    println!(&quot;After mutable borrow is done {:?}&quot;, list);
}</code></pre></pre>
<p>Moving ownership into a closure is often used to pass data to threads,
because a borrow would mean that the data could be accessed concurrently.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency-vs-parallelism"><a class="header" href="#concurrency-vs-parallelism">Concurrency vs Parallelism</a></h1>
<p>Rust supports multiple threads of execution in a single address space.</p>
<ul>
<li><em>Native</em> threads in Rust wrap the OS processes 1:1. These threads are capable of true parallelism/concurrency because they can be running on multiple physical CPUs simultaneously.</li>
<li><em>Light-weight</em> threads are also supported in Rust. These run-times multiplex multiple logical threads on a single native thread.</li>
</ul>
<p>The words concurrent and parallel are often used interchangeably, and from Rust's point of view have similar safety and memory sharing implications.</p>
<ul>
<li><em>Concurrent</em> programs typically use mutiple threads for scaling or functional decomposition (e.g. microservices). The threads are largely independent even if they are performing the same function
<ul>
<li>For example, <em>Netflix</em> might use thousands of threads to stream media to its customers.</li>
<li>Data is often <em>moved</em> between threads, e.g. SQL queries</li>
</ul>
</li>
<li><em>Parallel</em> programs use multiple threads to solve a problem faster. The threads usually have to communicate and coordinate to decompose the data space and maintain its integrity
<ul>
<li>For example, IBM's <em>Deep Blue</em> employed thousands of threads to search the game tree in its chess player.</li>
<li>Data is often <em>shared</em> between threads, e.g. matrices in numerical appliations</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-threads"><a class="header" href="#introduction-to-threads">Introduction to Threads</a></h1>
<p>Use <a href="https://doc.rust-lang.org/std/thread/fn.spawn.html">thread::spawn</a> to create a thread:</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;thread count {}&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;main count {}&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().expect(&quot;child panicked!&quot;);
}</code></pre></pre>
<p>You can move data into and out of threads:</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let mut list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {:?}&quot;, list);

    let thread_output = thread::spawn(move || {
        println!(&quot;I own this: {:?}&quot;, list);
        list.push(4);
        list
    });

    //println!(&quot;You can't print list here {:?}&quot;, list);
    
    if let Ok(list) = thread_output.join() {
        println!(&quot;And now main owns it again {:?}&quot;, list);
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channels"><a class="header" href="#channels">Channels</a></h1>
<p><em>Channels</em> are used for <em>message passing</em> between threads.
From the Go language documentation:</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<p>Back in the day, there was much ado about the <em>duality</em> of message passing vs
shared memory. The Linda language tried to implement a distributed shared memory
abstraction using message passing.</p>
<p>Today, most message passing APIs are implemented using shared memory. The main
reason: <em>copying memory is expensive</em>. It is <em>very</em> difficult for the advantages
of thread code and data locality to overcome the costs of the copy.</p>
<p>Message passing is usually used in concurrent (vs parallel) systems, and of
course heavily used in distributed systems.</p>
<p>A Rust <a href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html"><code>mpsc::channel</code></a> is almost exactly like a Unix domain socket or pipe.</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;
use std::time::{Duration, Instant};

fn main() {
    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();  // so we can have two senders
    thread::spawn(move || {
        let start = Instant::now();
        for _ in 1..5 {
            let msg = format!(&quot; &lt;t1: elapsed {:?}&gt; &quot;, start.elapsed());
            tx1.send(msg).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot; #t2# &quot;),
            String::from(&quot; #t2 again# &quot;),
            String::from(&quot; #t2 more# &quot;),
            String::from(&quot; #t2 last# &quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;{}&quot;, received);
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bi-directional-channels"><a class="header" href="#bi-directional-channels">Bi-directional Channels</a></h1>
<p>A <code>channel</code> is a multiple-producer-single-consumer pipe <em>in one direction</em>.
Many concurrent programs are client-server or request-response architectures,
yet Rust core does not support bi-directional channels.</p>
<p>The trick is for the client to include the reply channel in the server request </p>
<pre><pre class="playground"><code class="language-rust">extern crate chrono;
use chrono::offset::Local;
use std::sync::mpsc;
use std::thread;
use chrono::DateTime;
use std::time::{Duration, SystemTime};

enum Message {
    Request { rsvp: mpsc::Sender&lt;Message&gt;, op: i32 },
    Response { data: SystemTime },
}

fn main() {
    let (server_tx, server_rx) = mpsc::channel::&lt;Message&gt;();

    let client = thread::spawn(move || {
        let (tx, rx) = mpsc::channel::&lt;Message&gt;();

        for i in 1..4 {
            let msg = Message::Request { rsvp: tx.clone(), op: i };
            server_tx.send(msg).expect(&quot;send to server failed&quot;);
            if let Ok(msg) = rx.recv() {
                match msg {
                    Message::Request{..} =&gt; println!(&quot;unexpected request&quot;),
                    Message::Response{ data } =&gt; {
                        let datetime: DateTime&lt;Local&gt; = data.into();
                        println!(&quot;response: {}&quot;, datetime);
                    }
                }
            }
            thread::sleep(Duration::from_secs(i as u64));
        }
    });

    let server = thread::spawn(move || {
        while let Ok(request) = server_rx.recv() {
            match request {
                Message::Request { rsvp, op } =&gt; {
                    println!(&quot;server got request {}&quot;, op);
                    let msg = Message::Response { data: SystemTime::now() };
                    rsvp.send(msg).expect(&quot;send to client failed&quot;);
                }
                Message::Response{..} =&gt; println!(&quot;unexpected response&quot;),
            }
        }
    });

    let _ = client.join().expect(&quot;unexpected client panic&quot;);
    let _ = server.join().expect(&quot;unexpected server panic&quot;);
}
</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
