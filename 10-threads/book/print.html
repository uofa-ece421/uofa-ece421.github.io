<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Concurrency in Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="closures.html"><strong aria-hidden="true">1.</strong> Closures</a></li><li class="chapter-item expanded "><a href="cvp.html"><strong aria-hidden="true">2.</strong> Concurrency vs Parallelism</a></li><li class="chapter-item expanded "><a href="threads.html"><strong aria-hidden="true">3.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="channels.html"><strong aria-hidden="true">4.</strong> Channels</a></li><li class="chapter-item expanded "><a href="request-response.html"><strong aria-hidden="true">5.</strong> Request/Response</a></li><li class="chapter-item expanded "><a href="parallel.html"><strong aria-hidden="true">6.</strong> Parallelism</a></li><li class="chapter-item expanded "><a href="locks.html"><strong aria-hidden="true">7.</strong> Locks</a></li><li class="chapter-item expanded "><a href="quicksort.html"><strong aria-hidden="true">8.</strong> Parallelizing Quicksort</a></li><li class="chapter-item expanded "><a href="bench.html"><strong aria-hidden="true">9.</strong> Benchmarking and Tuning</a></li><li class="chapter-item expanded "><a href="pools.html"><strong aria-hidden="true">10.</strong> Thread Pools</a></li><li class="chapter-item expanded "><a href="scope.html"><strong aria-hidden="true">11.</strong> Scoped Threads</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Concurrency in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<p><em>Closures</em> are anonymous functions, sometimes called <em>lambda</em> functions, that
can be saved in a variable or passed as arguments to other functions.</p>
<pre><pre class="playground"><code class="language-rust">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }

fn main() {
    let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
    let add_one_v3 = |x|             { x + 1 };
    let add_one_v4 = |x|               x + 1  ;

    assert_eq!(add_one_v1(5), add_one_v2(5));
    assert_eq!(add_one_v3(5), add_one_v4(5));

    let ptr: fn(u32) -&gt; u32 = add_one_v1;
    let closure: fn(u32) -&gt; u32 = |x| x + 1;

    assert_eq!(ptr(10), closure(10));
}</code></pre></pre>
<p>Functions that expect closures as arguments implement the <code>FnOnce</code> Trait</p>
<ul>
<li><code>FnOnce</code> as in <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else">Option::unwrap_or_else</a></li>
<li><code>FnMut</code> is a subtrait of <code>FnOnce</code>, as in <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map">Iterator::map</a></li>
<li><code>Fn</code> is a subtrait of both <code>FnOnce</code> and <code>FnMut</code>, and is different that a function pointer <code>fn</code> (which is a primitive type).</li>
</ul>
<p>Closures are typically short, simple and relevant to a specific context, compared
to functions that are usually more general purpose or context insensitive.</p>
<h3 id="borrows-and-moves"><a class="header" href="#borrows-and-moves">Borrows and Moves</a></h3>
<p>Closures can capture values from their environment in three ways:
immutable borrow, mutable borrow, and move. This is similar to the way function
parameters work, although it now applies to the closure body. The compiler can
usually infer which type of capture to use.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {:?}&quot;, list);

    let only_borrows = || println!(&quot;From closure: {:?}&quot;, list);

    println!(&quot;Before calling closure: {:?}&quot;, list);
    only_borrows();

    let mut borrows_mutably = || list.push(4);

    // println!(&quot;both a mutable and immutable borrow: {:?}&quot;, list);
    borrows_mutably();

    println!(&quot;After mutable borrow is done {:?}&quot;, list);
}</code></pre></pre>
<p>Moving ownership into a closure is often used to pass data to threads,
because a borrow would mean that the data could be accessed concurrently.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency-vs-parallelism"><a class="header" href="#concurrency-vs-parallelism">Concurrency vs Parallelism</a></h1>
<p>Rust supports multiple threads of execution in a single address space.</p>
<ul>
<li><em>Native</em> threads in Rust wrap the OS processes 1:1. These threads are capable of true parallelism/concurrency because they can be running on multiple physical CPUs simultaneously.</li>
<li><em>Light-weight</em> threads are also supported in Rust. These run-times multiplex multiple logical threads on a single native thread.</li>
</ul>
<p>The words concurrent and parallel are often used interchangeably, and from Rust's point of view have similar safety and memory sharing implications.</p>
<ul>
<li><em>Concurrent</em> programs typically use mutiple threads for scaling or functional decomposition (e.g. microservices). The threads are largely independent even if they are performing the same function
<ul>
<li>For example, <em>Netflix</em> might use thousands of threads to stream media to its customers.</li>
<li>Data is often <em>moved</em> between threads, e.g. SQL queries</li>
</ul>
</li>
<li><em>Parallel</em> programs use multiple threads to solve a problem faster. The threads usually have to communicate and coordinate to decompose the data space and maintain its integrity
<ul>
<li>For example, IBM's <em>Deep Blue</em> employed thousands of threads to search the game tree in its chess player.</li>
<li>Data is often <em>shared</em> between threads, e.g. matrices in numerical appliations</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-threads"><a class="header" href="#introduction-to-threads">Introduction to Threads</a></h1>
<p>Use <a href="https://doc.rust-lang.org/std/thread/fn.spawn.html">thread::spawn</a> to create a thread:</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;thread count {}&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;main count {}&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().expect(&quot;child panicked!&quot;);
}</code></pre></pre>
<p>You can move data into and out of threads:</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let mut list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {:?}&quot;, list);

    let thread_output = thread::spawn(move || {
        println!(&quot;I own this: {:?}&quot;, list);
        list.push(4);
        list
    });

    //println!(&quot;You can't print list here {:?}&quot;, list);
    
    if let Ok(list) = thread_output.join() {
        println!(&quot;And now main owns it again {:?}&quot;, list);
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channels"><a class="header" href="#channels">Channels</a></h1>
<p><em>Channels</em> are used for <em>message passing</em> between threads.
From the Go language documentation:</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<p>Back in the day, there was much ado about the <em>duality</em> of message passing vs
shared memory. The Linda language tried to implement a distributed shared memory
abstraction using message passing.</p>
<p>Today, most message passing APIs are implemented using shared memory. The main
reason: <em>copying memory is expensive</em>. It is <em>very</em> difficult for the advantages
of thread code and data locality to overcome the costs of the copy.</p>
<p>Message passing is usually used in concurrent (vs parallel) systems, and of
course heavily used in distributed systems.</p>
<p>A Rust <a href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html"><code>mpsc::channel</code></a> is almost exactly like a Unix domain socket or pipe.</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;
use std::time::{Duration, Instant};

fn main() {
    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();  // so we can have two senders
    thread::spawn(move || {
        let start = Instant::now();
        for _ in 1..5 {
            let msg = format!(&quot; &lt;t1: elapsed {:?}&gt; &quot;, start.elapsed());
            tx1.send(msg).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot; #t2# &quot;),
            String::from(&quot; #t2 again# &quot;),
            String::from(&quot; #t2 more# &quot;),
            String::from(&quot; #t2 last# &quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;{}&quot;, received);
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bi-directional-channels"><a class="header" href="#bi-directional-channels">Bi-directional Channels</a></h1>
<p>A <code>channel</code> is a multiple-producer-single-consumer pipe <em>in one direction</em>.
Many concurrent programs are client-server or request-response architectures,
yet Rust core does not support bi-directional channels.</p>
<p>The trick is for the client to include the reply channel in the server request </p>
<pre><pre class="playground"><code class="language-rust">extern crate chrono;
use chrono::offset::Local;
use std::sync::mpsc;
use std::thread;
use chrono::DateTime;
use std::time::{Duration, SystemTime};

enum Message {
    Request { rsvp: mpsc::Sender&lt;Message&gt;, op: i32 },
    Response { data: SystemTime },
}

fn main() {
    let (server_tx, server_rx) = mpsc::channel::&lt;Message&gt;();

    let client = thread::spawn(move || {
        let (tx, rx) = mpsc::channel::&lt;Message&gt;();

        for i in 1..4 {
            let msg = Message::Request { rsvp: tx.clone(), op: i };
            server_tx.send(msg).expect(&quot;send to server failed&quot;);
            if let Ok(msg) = rx.recv() {
                match msg {
                    Message::Request{..} =&gt; println!(&quot;unexpected request&quot;),
                    Message::Response{ data } =&gt; {
                        let datetime: DateTime&lt;Local&gt; = data.into();
                        println!(&quot;response: {}&quot;, datetime);
                    }
                }
            }
            thread::sleep(Duration::from_secs(i as u64));
        }
    });

    let server = thread::spawn(move || {
        while let Ok(request) = server_rx.recv() {
            match request {
                Message::Request { rsvp, op } =&gt; {
                    println!(&quot;server got request {}&quot;, op);
                    let msg = Message::Response { data: SystemTime::now() };
                    rsvp.send(msg).expect(&quot;send to client failed&quot;);
                }
                Message::Response{..} =&gt; println!(&quot;unexpected response&quot;),
            }
        }
    });

    let _ = client.join().expect(&quot;unexpected client panic&quot;);
    let _ = server.join().expect(&quot;unexpected server panic&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parallel-programming"><a class="header" href="#parallel-programming">Parallel Programming</a></h1>
<p>Parallel algorithms typically share data structures among multiple threads,
with the goal of solving a single problem in less time.</p>
<p>Data parallel algorithms can sometimes be classified <em>SIMD</em> (Single Instruction
Multiple Data) because each thread performs the same algorithm on a different
portion of the data.</p>
<p>Generally speaking, parallelism is hard, or to be more specific, achieving
<var>Speedup &gt; 1</var> is hard.</p>
<blockquote>
<p><var>Speedup<sub>N</sub> = T(sequential)/T(parallel<sub>N</sub>)</var></p>
</blockquote>
<p>Note that <var>T(sequential)</var> is typically <em>not</em> <var>T(parallel<sub>1</sub>)</var></p>
<p><strong>Amdahl's Law</strong> (Speedup):</p>
<blockquote>
<p><var>S<sub>latency</sub>(s) = [(1 - p) + p/s]<sup>-1</sup></var></p>
</blockquote>
<p>where</p>
<ul>
<li><var>S<sub>latency</sub></var> is the theoretical speedup of the execution of the whole task</li>
<li><var>s</var> is the speedup of the part that can be parallelized</li>
<li><var>p</var> is the proportion that can be parallelized</li>
</ul>
<p>For example, if 90% of a sequential program can be parallelized,
the best speedup you can get is <var>S</var> = 1/0.1 = 10 even if you managed to
get the parallel execution time to zero!</p>
<p><strong>Gustafson's Law</strong> (Scaleup):</p>
<blockquote>
<p><var>S = 1 + (N - 1)*p</var></p>
</blockquote>
<p>where</p>
<ul>
<li><var>N</var> is the number of processors used</li>
</ul>
<p>Gustafson's Law addresses the fact that most people increase the problem size
as they increase the number of processors.</p>
<p>For example, if you used 100 processors on a program that is 90% parallelizable,
Gustafson's Law predicts a scaleup <var>S</var> = 1 + (100 - 1)*0.9 = 90.1</p>
<p><strong>Inherent Costs of Parallelization</strong></p>
<p>In addition to the sequential part that can't be parallelized, you have to
minimize or amortize the expense of creating and coordinating threads:</p>
<ul>
<li>thread creation (<code>spawn</code>)</li>
<li>thread communication, e.g. fork/join (barriers), events</li>
<li>data integrity (locks)</li>
<li>cache coherence and locality</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-locks"><a class="header" href="#using-locks">Using Locks</a></h1>
<p>A <code>Mutex&lt;T&gt;</code> is a wraps a smart pointer called a <code>MutexGuard</code>, which implements
the <code>Deref</code> and <code>Drop</code> traits. Rust supports for data integrity:</p>
<ul>
<li>must call <code>lock</code> before accessing the data protected by the mutex</li>
<li>lock is automatically released when owner exits scope</li>
</ul>
<p>Rust is conservative about which data needs to be locked (e.g. globals).
Note that locks, threads, etc are provided by the runtime - they are not
intrinsically part of the language itself. Although Rust's ownership rules
go a long way, Rust cannot detect deadlock or fix your performance problems!</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;
use std::thread;
use std::time::Duration;

fn main() {
    let counter = Mutex::new(0);
    let handle = thread::spawn(move || {
        for i in 1..10 {
            {
                let mut val = counter.lock().unwrap();
                *val = i;
            }
            println!(&quot;number {:?} from the spawned thread!&quot;, counter);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();
    //println!(&quot;final number {:?} from main&quot;, counter);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}</code></pre></pre>
<h3 id="send-and-sync"><a class="header" href="#send-and-sync"><code>Send</code> and <code>Sync</code></a></h3>
<p><em>Send</em> is a marker trait that indicates that <em>ownership</em> of the value can be
<code>move</code>d between threads.</p>
<ul>
<li>Almost every Rust type is <code>Send</code>, except for types explicity documented as not being thread-safe, e.g. <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code></li>
<li>Any compound type composed entirely of <code>Send</code> types is also <code>Send</code>.</li>
<li>A type <em>not</em> marked <code>Send</code> (e.g. raw pointers) can be passed between threads by writing an <code>unsafe</code> trait. In this case, the implementor is taking responsibility for making sure the transfer occurrs correctly.</li>
</ul>
<p><em>Sync</em> is a marker trait that indicates that the value can be referenced from
multiple threads.</p>
<ul>
<li>A type <code>T</code> is <code>Sync</code> if <code>&amp;T</code> is <code>Send</code>.</li>
<li>Any compound type composed entirely of <code>Sync</code> types is also <code>Sync</code>.</li>
<li>You can also implement <code>unsafe</code> traits for types not marked <code>Sync</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parallelizing-quicksort"><a class="header" href="#parallelizing-quicksort">Parallelizing Quicksort</a></h1>
<h3 id="sequential-quicksort"><a class="header" href="#sequential-quicksort">Sequential Quicksort</a></h3>
<p>Works by partitioning the data into two halves, such that the values below the
<em>pivot</em> index are all less than the values above the pivot.</p>
<p>Then it recursively calls itself on the two partitions.</p>
<p>The average complexity is <var>O(n*log<sub>2</sub>n)</var> and the worst case
is <var>O(n<sup>2</sup>)</var>, which happens when the data is already sorted.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate rand;
</span><span class="boring">
</span><span class="boring">use std::env;
</span><span class="boring">use std::thread;
</span><span class="boring">use rand::Rng;
</span><span class="boring">use std::time::Instant;
</span><span class="boring">use std::convert::TryInto;
</span><span class="boring">
</span>fn quicksort&lt;T: PartialOrd&gt;(v: &amp;mut [T]) {
    if v.len() &lt;= 1 {
        return;
    }

    let mid = partition(v);
    let (lo, hi) = v.split_at_mut(mid);
    quicksort(lo);
    quicksort(hi);
}

fn partition&lt;T: PartialOrd&gt;(v: &amp;mut [T]) -&gt; usize {
    let hi = v.len() - 1;
    let lo = 0;
    let pivot = hi;

    let mut i = 0;
    for j in lo..hi {
        if v[j] &lt;= v[pivot] {
            v.swap(i, j);
            i += 1;
        }
    }
    v.swap(i, pivot);
    i
}
<span class="boring">
</span><span class="boring">fn parallel_quicksort&lt;T: PartialOrd + std::marker::Send&gt;(v: &amp;mut [T]) {
</span><span class="boring">    if v.len() &lt;= 1 {
</span><span class="boring">        return;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    if v.len() &lt; 2048 { // At some point it won't pay to start more threads
</span><span class="boring">        quicksort(v);
</span><span class="boring">        return;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let mid = partition(v);
</span><span class="boring">    let (lo, hi) = v.split_at_mut(mid);
</span><span class="boring">
</span><span class="boring">    let lo_handle = thread::spawn(move || { parallel_quicksort(lo) });
</span><span class="boring">    let hi_handle = thread::spawn(move || { parallel_quicksort(hi) });
</span><span class="boring">
</span><span class="boring">    lo_handle.join().unwrap();
</span><span class="boring">    hi_handle.join().unwrap();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn initialize_data(len: usize) -&gt; Vec&lt;u32&gt; {
</span><span class="boring">    let mut data = Vec::with_capacity(len);
</span><span class="boring">    let mut rng = rand::thread_rng();
</span><span class="boring">
</span><span class="boring">    data.resize(len, 0);
</span><span class="boring">    for i in 0..len {
</span><span class="boring">        data[i] = rng.gen_range(0..len).try_into().unwrap();
</span><span class="boring">    }
</span><span class="boring">    data
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn reinitialize_data(v: &amp;mut [u32]) {
</span><span class="boring">    let mut rng = rand::thread_rng();
</span><span class="boring">    let len = v.len();
</span><span class="boring">    for i in 0..len {
</span><span class="boring">        v[i] = rng.gen_range(0..len).try_into().unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">    
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let len = match args.get(1) {
</span><span class="boring">        Some(slen) =&gt; match slen.parse::&lt;usize&gt;() {
</span><span class="boring">            Ok(num) =&gt; num,
</span><span class="boring">            Err(e) =&gt; {
</span><span class="boring">                println!(&quot;bad length: {}&quot;, e);
</span><span class="boring">                return;
</span><span class="boring">            }
</span><span class="boring">        },
</span><span class="boring">        None =&gt; {
</span><span class="boring">            println!(&quot;Using default length {}&quot;, 1000000);
</span><span class="boring">            1000000 as usize
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">        
</span><span class="boring">    let mut data = initialize_data(len);
</span><span class="boring">
</span><span class="boring">    let start = Instant::now();
</span><span class="boring">    parallel_quicksort(&amp;mut data);
</span><span class="boring">    let elapsed = Instant::now() - start;
</span><span class="boring">
</span><span class="boring">    let parallel_usec = u64::from(elapsed.subsec_micros()) + elapsed.as_secs()*1000000u64;
</span><span class="boring">    println!(&quot;sorted {} values in parallel in {} usec&quot;, len, parallel_usec);  
</span><span class="boring">
</span><span class="boring">    if !data.windows(2).all(|w| w[0] &lt;= w[1]) {
</span><span class="boring">        println!(&quot;sort failed!&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    reinitialize_data(&amp;mut data);
</span><span class="boring">
</span><span class="boring">    let start = Instant::now();
</span><span class="boring">    quicksort(&amp;mut data);
</span><span class="boring">    let elapsed = Instant::now() - start;
</span><span class="boring">
</span><span class="boring">    let sequential_usec = u64::from(elapsed.subsec_micros()) + elapsed.as_secs()*1000000u64;
</span><span class="boring">    println!(&quot;sorted {} values in {} usec&quot;, len, sequential_usec);  
</span><span class="boring">    
</span><span class="boring">    if !data.windows(2).all(|w| w[0] &lt;= w[1]) {
</span><span class="boring">        println!(&quot;sort failed!&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    println!(&quot;speedup: {}&quot;, (sequential_usec as f64)/(parallel_usec as f64));
</span><span class="boring">}</span></code></pre></pre>
<p>Since the two halves are disjoint we don't even need locks!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate rand;
</span><span class="boring">
</span><span class="boring">use std::env;
</span><span class="boring">use std::thread;
</span><span class="boring">use rand::Rng;
</span><span class="boring">use std::time::Instant;
</span><span class="boring">use std::convert::TryInto;
</span><span class="boring">
</span><span class="boring">fn quicksort&lt;T: PartialOrd&gt;(v: &amp;mut [T]) {
</span><span class="boring">    if v.len() &lt;= 1 {
</span><span class="boring">        return;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let mid = partition(v);
</span><span class="boring">    let (lo, hi) = v.split_at_mut(mid);
</span><span class="boring">    quicksort(lo);
</span><span class="boring">    quicksort(hi);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn partition&lt;T: PartialOrd&gt;(v: &amp;mut [T]) -&gt; usize {
</span><span class="boring">    let hi = v.len() - 1;
</span><span class="boring">    let lo = 0;
</span><span class="boring">    let pivot = hi;
</span><span class="boring">
</span><span class="boring">    let mut i = 0;
</span><span class="boring">    for j in lo..hi {
</span><span class="boring">        if v[j] &lt;= v[pivot] {
</span><span class="boring">            v.swap(i, j);
</span><span class="boring">            i += 1;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    v.swap(i, pivot);
</span><span class="boring">    i
</span><span class="boring">}
</span><span class="boring">
</span>fn parallel_quicksort&lt;T: PartialOrd + std::marker::Send&gt;(v: &amp;mut [T]) {
    if v.len() &lt;= 1 {
        return;
    }

    if v.len() &lt; 2048 { // At some point it won't pay to start more threads
        quicksort(v);
        return;
    }

    let mid = partition(v);
    let (lo, hi) = v.split_at_mut(mid);

    let lo_handle = thread::spawn(move || { parallel_quicksort(lo) });
    let hi_handle = thread::spawn(move || { parallel_quicksort(hi) });

    lo_handle.join().unwrap();
    hi_handle.join().unwrap();
}
<span class="boring">
</span><span class="boring">fn initialize_data(len: usize) -&gt; Vec&lt;u32&gt; {
</span><span class="boring">    let mut data = Vec::with_capacity(len);
</span><span class="boring">    let mut rng = rand::thread_rng();
</span><span class="boring">
</span><span class="boring">    data.resize(len, 0);
</span><span class="boring">    for i in 0..len {
</span><span class="boring">        data[i] = rng.gen_range(0..len).try_into().unwrap();
</span><span class="boring">    }
</span><span class="boring">    data
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn reinitialize_data(v: &amp;mut [u32]) {
</span><span class="boring">    let mut rng = rand::thread_rng();
</span><span class="boring">    let len = v.len();
</span><span class="boring">    for i in 0..len {
</span><span class="boring">        v[i] = rng.gen_range(0..len).try_into().unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">    
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let len = match args.get(1) {
</span><span class="boring">        Some(slen) =&gt; match slen.parse::&lt;usize&gt;() {
</span><span class="boring">            Ok(num) =&gt; num,
</span><span class="boring">            Err(e) =&gt; {
</span><span class="boring">                println!(&quot;bad length: {}&quot;, e);
</span><span class="boring">                return;
</span><span class="boring">            }
</span><span class="boring">        },
</span><span class="boring">        None =&gt; {
</span><span class="boring">            println!(&quot;Using default length {}&quot;, 1000000);
</span><span class="boring">            1000000 as usize
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">        
</span><span class="boring">    let mut data = initialize_data(len);
</span><span class="boring">
</span><span class="boring">    let start = Instant::now();
</span><span class="boring">    parallel_quicksort(&amp;mut data);
</span><span class="boring">    let elapsed = Instant::now() - start;
</span><span class="boring">
</span><span class="boring">    let parallel_usec = u64::from(elapsed.subsec_micros()) + elapsed.as_secs()*1000000u64;
</span><span class="boring">    println!(&quot;sorted {} values in parallel in {} usec&quot;, len, parallel_usec);  
</span><span class="boring">
</span><span class="boring">    if !data.windows(2).all(|w| w[0] &lt;= w[1]) {
</span><span class="boring">        println!(&quot;sort failed!&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    reinitialize_data(&amp;mut data);
</span><span class="boring">
</span><span class="boring">    let start = Instant::now();
</span><span class="boring">    quicksort(&amp;mut data);
</span><span class="boring">    let elapsed = Instant::now() - start;
</span><span class="boring">
</span><span class="boring">    let sequential_usec = u64::from(elapsed.subsec_micros()) + elapsed.as_secs()*1000000u64;
</span><span class="boring">    println!(&quot;sorted {} values in {} usec&quot;, len, sequential_usec);  
</span><span class="boring">    
</span><span class="boring">    if !data.windows(2).all(|w| w[0] &lt;= w[1]) {
</span><span class="boring">        println!(&quot;sort failed!&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    println!(&quot;speedup: {}&quot;, (sequential_usec as f64)/(parallel_usec as f64));
</span><span class="boring">}</span></code></pre></pre>
<p>To get around the lifetime problem, use <em>scoped</em> threads from <code>crossbeam</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate rand;
</span><span class="boring">
</span><span class="boring">use std::env;
</span><span class="boring">use rand::Rng;
</span><span class="boring">use std::time::Instant;
</span><span class="boring">use std::convert::TryInto;
</span><span class="boring">
</span><span class="boring">const MILLION: usize = 1024*1024;
</span><span class="boring">
</span><span class="boring">fn quicksort&lt;T: PartialOrd&gt;(v: &amp;mut [T]) {
</span><span class="boring">    if v.len() &lt;= 1 {
</span><span class="boring">        return;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let mid = partition(v);
</span><span class="boring">    let (lo, hi) = v.split_at_mut(mid);
</span><span class="boring">    quicksort(lo);
</span><span class="boring">    quicksort(hi);
</span><span class="boring">}
</span><span class="boring">
</span>fn parallel_quicksort&lt;T: PartialOrd + std::marker::Send&gt;(v: &amp;mut [T]) {
    if v.len() &lt;= 1 {
        return;
    }

    if v.len() &lt;= 2048 {
        quicksort(v);
        return;
    }

    crossbeam::scope(|scope| {
        let mid = partition(v);
        let (lo, hi) = v.split_at_mut(mid);
        scope.spawn(move |_| parallel_quicksort(lo));
        scope.spawn(move |_| parallel_quicksort(hi));
    }).expect(&quot;thread spawn failed&quot;);
}
<span class="boring">
</span><span class="boring">fn partition&lt;T: PartialOrd&gt;(v: &amp;mut [T]) -&gt; usize {
</span><span class="boring">    let hi = v.len() - 1;
</span><span class="boring">    let lo = 0;
</span><span class="boring">    let pivot = hi;
</span><span class="boring">
</span><span class="boring">    let mut i = 0;
</span><span class="boring">    for j in lo..hi {
</span><span class="boring">        if v[j] &lt;= v[pivot] {
</span><span class="boring">            v.swap(i, j);
</span><span class="boring">            i += 1;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    v.swap(i, pivot);
</span><span class="boring">    i
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn initialize_data(len: usize) -&gt; Vec&lt;u32&gt; {
</span><span class="boring">    let mut data = Vec::with_capacity(len);
</span><span class="boring">    let mut rng = rand::thread_rng();
</span><span class="boring">
</span><span class="boring">    data.resize(len, 0);
</span><span class="boring">    for i in 0..len {
</span><span class="boring">        data[i] = rng.gen_range(0..len).try_into().unwrap();
</span><span class="boring">    }
</span><span class="boring">    data
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn reinitialize_data(v: &amp;mut [u32]) {
</span><span class="boring">    let mut rng = rand::thread_rng();
</span><span class="boring">    let len = v.len();
</span><span class="boring">    for i in 0..len {
</span><span class="boring">        v[i] = rng.gen_range(0..len).try_into().unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn bench&lt;F: FnOnce(&amp;mut [u32])&gt;(sort: F, data: &amp;mut [u32]) -&gt; u64 {
</span><span class="boring">    reinitialize_data(data);
</span><span class="boring">
</span><span class="boring">    let start = Instant::now();
</span><span class="boring">    sort(data);
</span><span class="boring">    let elapsed = Instant::now() - start;
</span><span class="boring">
</span><span class="boring">    if !data.windows(2).all(|w| w[0] &lt;= w[1]) {
</span><span class="boring">        println!(&quot;sort failed!&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    u64::from(elapsed.subsec_micros()) + elapsed.as_secs()*1000000u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    // First argument is the vector length
</span><span class="boring">    let len = match args.get(1) {
</span><span class="boring">        Some(slen) =&gt; match slen.parse::&lt;usize&gt;() {
</span><span class="boring">            Ok(num) =&gt; num,
</span><span class="boring">            Err(e) =&gt; {
</span><span class="boring">                println!(&quot;ignoring bad length: {}&quot;, e);
</span><span class="boring">                MILLION as usize
</span><span class="boring">            }
</span><span class="boring">        },
</span><span class="boring">        None =&gt; MILLION as usize,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let mut data = initialize_data(len);
</span><span class="boring">
</span><span class="boring">    let mut par_mean: f64 = 0.0;
</span><span class="boring">    for run in 0..10 {
</span><span class="boring">        let elapsed = bench(parallel_quicksort, &amp;mut data);
</span><span class="boring">        println!(&quot;parallel {}: {} usec&quot;, run, elapsed);
</span><span class="boring">        par_mean += elapsed as f64;
</span><span class="boring">    }
</span><span class="boring">    par_mean /= 10.0;
</span><span class="boring">    println!(&quot;parallel mean: {} usec&quot;, par_mean);
</span><span class="boring">
</span><span class="boring">    let mut seq_mean: f64 = 0.0;
</span><span class="boring">    for run in 0..10 {
</span><span class="boring">        let elapsed = bench(quicksort, &amp;mut data);
</span><span class="boring">        println!(&quot;sequential {}: {}&quot;, run, elapsed);
</span><span class="boring">        seq_mean += elapsed as f64;
</span><span class="boring">    }
</span><span class="boring">    seq_mean /= 10.0;
</span><span class="boring">    println!(&quot;sequential mean: {} usec&quot;, seq_mean);
</span><span class="boring">
</span><span class="boring">    println!(&quot;speedup: {}&quot;, seq_mean/par_mean);
</span><span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmarking-and-tuning"><a class="header" href="#benchmarking-and-tuning">Benchmarking and Tuning</a></h1>
<p>Let's see what awesome speedup we get!</p>
<p>First, setup a test harness</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate rand;
</span><span class="boring">
</span><span class="boring">use std::env;
</span><span class="boring">use rand::Rng;
</span><span class="boring">use std::time::Instant;
</span><span class="boring">use std::convert::TryInto;
</span><span class="boring">
</span><span class="boring">const MILLION: usize = 1024*1024;
</span><span class="boring">
</span><span class="boring">fn quicksort&lt;T: PartialOrd&gt;(v: &amp;mut [T]) {
</span><span class="boring">    if v.len() &lt;= 1 {
</span><span class="boring">        return;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let mid = partition(v);
</span><span class="boring">    let (lo, hi) = v.split_at_mut(mid);
</span><span class="boring">    quicksort(lo);
</span><span class="boring">    quicksort(hi);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn parallel_quicksort&lt;T: PartialOrd + std::marker::Send&gt;(v: &amp;mut [T]) {
</span><span class="boring">    if v.len() &lt;= 1 {
</span><span class="boring">        return;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    if v.len() &lt;= 2048 {
</span><span class="boring">        quicksort(v);
</span><span class="boring">        return;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    crossbeam::scope(|scope| {
</span><span class="boring">        let mid = partition(v);
</span><span class="boring">        let (lo, hi) = v.split_at_mut(mid);
</span><span class="boring">        scope.spawn(move |_| parallel_quicksort(lo));
</span><span class="boring">        scope.spawn(move |_| parallel_quicksort(hi));
</span><span class="boring">    }).expect(&quot;thread spawn failed&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn partition&lt;T: PartialOrd&gt;(v: &amp;mut [T]) -&gt; usize {
</span><span class="boring">    let hi = v.len() - 1;
</span><span class="boring">    let lo = 0;
</span><span class="boring">    let pivot = hi;
</span><span class="boring">
</span><span class="boring">    let mut i = 0;
</span><span class="boring">    for j in lo..hi {
</span><span class="boring">        if v[j] &lt;= v[pivot] {
</span><span class="boring">            v.swap(i, j);
</span><span class="boring">            i += 1;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    v.swap(i, pivot);
</span><span class="boring">    i
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn initialize_data(len: usize) -&gt; Vec&lt;u32&gt; {
</span><span class="boring">    let mut data = Vec::with_capacity(len);
</span><span class="boring">    let mut rng = rand::thread_rng();
</span><span class="boring">
</span><span class="boring">    data.resize(len, 0);
</span><span class="boring">    for i in 0..len {
</span><span class="boring">        data[i] = rng.gen_range(0..len).try_into().unwrap();
</span><span class="boring">    }
</span><span class="boring">    data
</span><span class="boring">}
</span><span class="boring">
</span>fn reinitialize_data(v: &amp;mut [u32]) {
    let mut rng = rand::thread_rng();
    let len = v.len();
    for i in 0..len {
        v[i] = rng.gen_range(0..len).try_into().unwrap();
    }
}

fn bench&lt;F: FnOnce(&amp;mut [u32])&gt;(sort: F, data: &amp;mut [u32]) -&gt; u64 {
    reinitialize_data(data);

    let start = Instant::now();
    sort(data);
    let elapsed = Instant::now() - start;

    if !data.windows(2).all(|w| w[0] &lt;= w[1]) {
        println!(&quot;sort failed!&quot;);
    }

    u64::from(elapsed.subsec_micros()) + elapsed.as_secs()*1000000u64
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    // First argument is the vector length
    let len = match args.get(1) {
        Some(slen) =&gt; match slen.parse::&lt;usize&gt;() {
            Ok(num) =&gt; num,
            Err(e) =&gt; {
                println!(&quot;ignoring bad length: {}&quot;, e);
                MILLION as usize
            }
        },
        None =&gt; MILLION as usize,
    };

    let mut data = initialize_data(len);

    let mut par_mean: f64 = 0.0;
    for run in 0..10 {
        let elapsed = bench(parallel_quicksort, &amp;mut data);
        println!(&quot;parallel {}: {} usec&quot;, run, elapsed);
        par_mean += elapsed as f64;
    }
    par_mean /= 10.0;
    println!(&quot;parallel mean: {} usec&quot;, par_mean);

    let mut seq_mean: f64 = 0.0;
    for run in 0..10 {
        let elapsed = bench(quicksort, &amp;mut data);
        println!(&quot;sequential {}: {}&quot;, run, elapsed);
        seq_mean += elapsed as f64;
    }
    seq_mean /= 10.0;
    println!(&quot;sequential mean: {} usec&quot;, seq_mean);

    println!(&quot;speedup: {}&quot;, seq_mean/par_mean);
}</code></pre></pre>
<p>Add some instrumentation</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use rand::Rng;
</span><span class="boring">use std::time::Instant;
</span><span class="boring">use std::sync::atomic::{AtomicU32, Ordering};
</span><span class="boring">
</span>const MILLION: u32 = 1024*1024;

static THREAD_COUNT: AtomicU32 = AtomicU32::new(0);
static PAR_SEQ_THRESHOLD: AtomicU32 = AtomicU32::new(2048);

fn parallel_quicksort&lt;T: PartialOrd + std::marker::Send&gt;(v: &amp;mut [T]) {
    if v.len() &lt;= 1 {
        return;
    }

    if v.len() &lt;= PAR_SEQ_THRESHOLD.load(Ordering::SeqCst) as usize {
        quicksort(v);
        return;
    }

    THREAD_COUNT.fetch_add(2, Ordering::SeqCst);
    
    crossbeam::scope(|scope| {
        let mid = partition(v);
        let (lo, hi) = v.split_at_mut(mid);
        scope.spawn(move |_| parallel_quicksort(lo));
        scope.spawn(move |_| parallel_quicksort(hi));
    }).expect(&quot;thread spawn failed&quot;);
}
<span class="boring">
</span><span class="boring">fn quicksort&lt;T: PartialOrd&gt;(v: &amp;mut [T]) {
</span><span class="boring">    if v.len() &lt;= 1 {
</span><span class="boring">        return;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let mid = partition(v);
</span><span class="boring">    let (lo, hi) = v.split_at_mut(mid);
</span><span class="boring">    quicksort(lo);
</span><span class="boring">    quicksort(hi);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn partition&lt;T: PartialOrd&gt;(v: &amp;mut [T]) -&gt; usize {
</span><span class="boring">    let hi = v.len() - 1;
</span><span class="boring">    let lo = 0;
</span><span class="boring">    let pivot = hi;
</span><span class="boring">
</span><span class="boring">    let mut i = 0;
</span><span class="boring">    for j in lo..hi {
</span><span class="boring">        if v[j] &lt;= v[pivot] {
</span><span class="boring">            v.swap(i, j);
</span><span class="boring">            i += 1;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    v.swap(i, pivot);
</span><span class="boring">    i
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn initialize_data(len: usize) -&gt; Vec&lt;u32&gt; {
</span><span class="boring">    let mut data = Vec::with_capacity(len);
</span><span class="boring">    let mut rng = rand::thread_rng();
</span><span class="boring">
</span><span class="boring">    data.resize(len, 0);
</span><span class="boring">    for i in 0..len {
</span><span class="boring">        data[i] = rng.gen_range(0..len).try_into().unwrap();
</span><span class="boring">    }
</span><span class="boring">    data
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn reinitialize_data(v: &amp;mut [u32]) {
</span><span class="boring">    let mut rng = rand::thread_rng();
</span><span class="boring">    let len = v.len();
</span><span class="boring">    for i in 0..len {
</span><span class="boring">        v[i] = rng.gen_range(0..len).try_into().unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn bench&lt;F: FnOnce(&amp;mut [u32])&gt;(sort: F, data: &amp;mut [u32]) -&gt; u64 {
</span><span class="boring">    reinitialize_data(data);
</span><span class="boring">
</span><span class="boring">    let start = Instant::now();
</span><span class="boring">    sort(data);
</span><span class="boring">    let elapsed = Instant::now() - start;
</span><span class="boring">
</span><span class="boring">    if !data.windows(2).all(|w| w[0] &lt;= w[1]) {
</span><span class="boring">        println!(&quot;sort failed!&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    u64::from(elapsed.subsec_micros()) + elapsed.as_secs()*1000000u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    // First argument is the vector length
</span><span class="boring">    let len = match args.get(1) {
</span><span class="boring">        Some(slen) =&gt; match slen.parse::&lt;usize&gt;() {
</span><span class="boring">            Ok(num) =&gt; num,
</span><span class="boring">            Err(e) =&gt; {
</span><span class="boring">                println!(&quot;ignoring bad length: {}&quot;, e);
</span><span class="boring">                MILLION as usize
</span><span class="boring">            }
</span><span class="boring">        },
</span><span class="boring">        None =&gt; MILLION as usize,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    // Second argument is the parallel/sequential threshold
</span><span class="boring">    match args.get(2) {
</span><span class="boring">        Some(val) =&gt; match val.parse::&lt;u32&gt;() {
</span><span class="boring">            Ok(t) =&gt; {
</span><span class="boring">                PAR_SEQ_THRESHOLD.store(t, Ordering::SeqCst);
</span><span class="boring">            },
</span><span class="boring">            Err(e) =&gt; println!(&quot;ignoring bad value: {}&quot;, e),
</span><span class="boring">        },
</span><span class="boring">        None =&gt; (),
</span><span class="boring">    };
</span><span class="boring">    println!(&quot;Using len {}, par/seq threshold {}&quot;, len, PAR_SEQ_THRESHOLD.load(Ordering::SeqCst));
</span><span class="boring">        
</span><span class="boring">    let mut data = initialize_data(len);
</span><span class="boring">
</span><span class="boring">    let mut par_mean: f64 = 0.0;
</span><span class="boring">    for run in 0..10 {
</span><span class="boring">        let elapsed = bench(parallel_quicksort, &amp;mut data);
</span><span class="boring">        let tcount = THREAD_COUNT.swap(0, Ordering::SeqCst);
</span><span class="boring">        println!(&quot;parallel {}: {} usec, {} threads&quot;, run, elapsed, tcount);
</span><span class="boring">        par_mean += elapsed as f64;
</span><span class="boring">    }
</span><span class="boring">    par_mean /= 10.0;
</span><span class="boring">    println!(&quot;parallel mean: {} usec&quot;, par_mean);
</span><span class="boring">
</span><span class="boring">    let mut seq_mean: f64 = 0.0;
</span><span class="boring">    for run in 0..10 {
</span><span class="boring">        let elapsed = bench(quicksort, &amp;mut data);
</span><span class="boring">        println!(&quot;sequential {}: {}&quot;, run, elapsed);
</span><span class="boring">        seq_mean += elapsed as f64;
</span><span class="boring">    }
</span><span class="boring">    seq_mean /= 10.0;
</span><span class="boring">    println!(&quot;sequential mean: {} usec&quot;, seq_mean);
</span><span class="boring">    
</span><span class="boring">
</span><span class="boring">    println!(&quot;speedup: {}&quot;, seq_mean/par_mean);
</span><span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thread-pools"><a class="header" href="#thread-pools">Thread Pools</a></h1>
<p>The idea is to amortize the cost of thread creation by doing it once at the
beginning and then reusing the body for different tasks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::sync::mpsc;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    threads: Vec&lt;Worker&gt;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    pub fn new(n: usize) -&gt; ThreadPool {
</span><span class="boring">        let mut workers = Vec::with_capacity(n);
</span><span class="boring">
</span><span class="boring">        for i in 0..n {
</span><span class="boring">            workers.push(Worker::new(i));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { threads: workers }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;mut self, f: F) -&gt; Worker
</span><span class="boring">    where F: FnOnce() + Send + 'static {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">        let w = self.threads.pop().expect(&quot;No more threads!&quot;);
</span><span class="boring">        println!(&quot;execute sending work to {}&quot;, w.id);
</span><span class="boring">        w.sender.send(Task::Work(job)).unwrap();
</span><span class="boring">        w
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn wait(&amp;mut self, w: Worker) {
</span><span class="boring">        if let Ok(rc) = w.receiver.recv() {
</span><span class="boring">            if !rc {
</span><span class="boring">                println!(&quot;worker failed?!&quot;);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        println!(&quot;worker {} is finished&quot;, w.id);
</span><span class="boring">        self.threads.push(w);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn drain(&amp;mut self) {
</span><span class="boring">        while let Some(w) = self.threads.pop() {
</span><span class="boring">            w.sender.send(Task::Quit).unwrap();
</span><span class="boring">            w.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }    
</span><span class="boring">}
</span><span class="boring">
</span>type Job = Box&lt;dyn FnOnce() + Send&gt;;

enum Task {
    Quit,
    Work(Job),
}

pub struct Worker {
    id: usize,
    sender: mpsc::Sender&lt;Task&gt;,
    receiver: mpsc::Receiver&lt;bool&gt;,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let (thread_sender, thread_receiver) = mpsc::channel(); 
        let (mgr_sender, mgr_receiver) = mpsc::channel(); 
        let thread = thread::spawn(move || {
            loop {
                let work: Task = thread_receiver.recv().unwrap();
                match work {
                    Task::Quit =&gt; {
                        break;
                    },
                    Task::Work(job) =&gt; {
                        job();
                    },
                }
                mgr_sender.send(true).expect(&quot;failed manager send&quot;);
            }
        });

        Worker { id, sender: thread_sender, receiver: mgr_receiver, thread }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The actual pool is just a collection of workers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::sync::mpsc;
</span><span class="boring">
</span>pub struct ThreadPool {
    threads: Vec&lt;Worker&gt;
}

impl ThreadPool {
    pub fn new(n: usize) -&gt; ThreadPool {
        let mut workers = Vec::with_capacity(n);

        for i in 0..n {
            workers.push(Worker::new(i));
        }

        ThreadPool { threads: workers }
    }

    pub fn execute&lt;F&gt;(&amp;mut self, f: F) -&gt; Worker
    where F: FnOnce() + Send + 'static {
        let job = Box::new(f);
        let w = self.threads.pop().expect(&quot;No more threads!&quot;);
        println!(&quot;execute sending work to {}&quot;, w.id);
        w.sender.send(Task::Work(job)).unwrap();
        w
    }

    pub fn wait(&amp;mut self, w: Worker) {
        if let Ok(rc) = w.receiver.recv() {
            if !rc {
                println!(&quot;worker failed?!&quot;);
            }
        }
        println!(&quot;worker {} is finished&quot;, w.id);
        self.threads.push(w);
    }

    pub fn drain(&amp;mut self) {
        while let Some(w) = self.threads.pop() {
            w.sender.send(Task::Quit).unwrap();
            w.thread.join().unwrap();
        }
    }    
}
<span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send&gt;;
</span><span class="boring">
</span><span class="boring">enum Task {
</span><span class="boring">    Quit,
</span><span class="boring">    Work(Job),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    sender: mpsc::Sender&lt;Task&gt;,
</span><span class="boring">    receiver: mpsc::Receiver&lt;bool&gt;,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let (thread_sender, thread_receiver) = mpsc::channel(); 
</span><span class="boring">        let (mgr_sender, mgr_receiver) = mpsc::channel(); 
</span><span class="boring">        let thread = thread::spawn(move || {
</span><span class="boring">            loop {
</span><span class="boring">                let work: Task = thread_receiver.recv().unwrap();
</span><span class="boring">                match work {
</span><span class="boring">                    Task::Quit =&gt; {
</span><span class="boring">                        break;
</span><span class="boring">                    },
</span><span class="boring">                    Task::Work(job) =&gt; {
</span><span class="boring">                        job();
</span><span class="boring">                    },
</span><span class="boring">                }
</span><span class="boring">                mgr_sender.send(true).expect(&quot;failed manager send&quot;);
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, sender: thread_sender, receiver: mgr_receiver, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>The pool is used in the main program:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use rand::Rng;
</span><span class="boring">use std::sync::atomic::{AtomicU32, Ordering};
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">
</span><span class="boring">mod tpool;
</span><span class="boring">
</span><span class="boring">const MILLION: u32 = 256; 
</span><span class="boring">static PAR_SEQ_THRESHOLD: AtomicU32 = AtomicU32::new(32);
</span><span class="boring">
</span>use tpool::ThreadPool;
use lazy_static::lazy_static;

lazy_static! {
    static ref THREAD_POOL: Mutex&lt;ThreadPool&gt; = Mutex::new(ThreadPool::new(8));
}

fn parallel_quicksort&lt;T: PartialOrd + std::marker::Send + std::marker::Sync&gt;(v: &amp;mut [T]) {
    if v.len() &lt;= 1 {
        return;
    }

    if v.len() &lt;= PAR_SEQ_THRESHOLD.load(Ordering::SeqCst) as usize {
        quicksort(v);
        return;
    }

    let mid = partition(v);
    // let (lo, hi) = v.split_at_mut(mid);
    let len = v.len();

    let w1 = THREAD_POOL.lock().unwrap().execute(move || { println!(&quot;exec: mid {}&quot;, mid); } );
    let w2 = THREAD_POOL.lock().unwrap().execute(move || { println!(&quot;exec: len {}&quot;, len); });
    THREAD_POOL.lock().unwrap().wait(w1);
    THREAD_POOL.lock().unwrap().wait(w2);
}
<span class="boring">
</span><span class="boring">fn quicksort&lt;T: PartialOrd&gt;(v: &amp;mut [T]) {
</span><span class="boring">    if v.len() &lt;= 1 {
</span><span class="boring">        return;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let mid = partition(v);
</span><span class="boring">    let (lo, hi) = v.split_at_mut(mid);
</span><span class="boring">    quicksort(lo);
</span><span class="boring">    quicksort(hi);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn partition&lt;T: PartialOrd&gt;(v: &amp;mut [T]) -&gt; usize {
</span><span class="boring">    let hi = v.len() - 1;
</span><span class="boring">    let lo = 0;
</span><span class="boring">    let pivot = hi;
</span><span class="boring">
</span><span class="boring">    let mut i = 0;
</span><span class="boring">    for j in lo..hi {
</span><span class="boring">        if v[j] &lt;= v[pivot] {
</span><span class="boring">            v.swap(i, j);
</span><span class="boring">            i += 1;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    v.swap(i, pivot);
</span><span class="boring">    i
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn initialize_data(len: usize) -&gt; Vec&lt;u32&gt; {
</span><span class="boring">    let mut data = Vec::with_capacity(len);
</span><span class="boring">    let mut rng = rand::thread_rng();
</span><span class="boring">
</span><span class="boring">    data.resize(len, 0);
</span><span class="boring">    for i in 0..len {
</span><span class="boring">        data[i] = rng.gen_range(0..len).try_into().unwrap();
</span><span class="boring">    }
</span><span class="boring">    data
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    // First argument is the vector length
</span><span class="boring">    let len = match args.get(1) {
</span><span class="boring">        Some(slen) =&gt; match slen.parse::&lt;usize&gt;() {
</span><span class="boring">            Ok(num) =&gt; num,
</span><span class="boring">            Err(e) =&gt; {
</span><span class="boring">                println!(&quot;ignoring bad length: {}&quot;, e);
</span><span class="boring">                MILLION as usize
</span><span class="boring">            }
</span><span class="boring">        },
</span><span class="boring">        None =&gt; MILLION as usize,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;len {}&quot;, len);
</span><span class="boring">    let mut v = initialize_data(len);
</span><span class="boring">    parallel_quicksort(&amp;mut v);
</span><span class="boring">
</span><span class="boring">    THREAD_POOL.lock().unwrap().drain();
</span><span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scoped-threads"><a class="header" href="#scoped-threads">Scoped Threads</a></h1>
<p>We need to create a scope, as desribed in <a href="https://doc.rust-lang.org/nightly/std/thread/fn.scope.html">std::thread::scope</a></p>
<p>And then we use <a href="https://doc.rust-lang.org/nightly/std/mem/fn.transmute.html">std::mem::transmute</a> to lie:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::mem;
</span><span class="boring">use std::sync::{mpsc, Mutex};
</span><span class="boring">use std::marker::PhantomData;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    threads: Mutex&lt;Vec&lt;Worker&gt;&gt;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    pub fn new(n: usize) -&gt; ThreadPool {
</span><span class="boring">        let threads = Mutex::new(Vec::with_capacity(n));
</span><span class="boring">        {
</span><span class="boring">            let mut workers = threads.lock().unwrap();
</span><span class="boring">            for i in 0..n {
</span><span class="boring">                workers.push(Worker::new(i));
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        ThreadPool { threads }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn execute(&amp;self, job: Task) -&gt; Worker {
</span><span class="boring">        let worker = {
</span><span class="boring">            let mut workers = self.threads.lock().unwrap();
</span><span class="boring">            workers.pop()
</span><span class="boring">        };
</span><span class="boring">        match worker {
</span><span class="boring">            Some(w) =&gt; {
</span><span class="boring">                w.sender.send(job).unwrap();
</span><span class="boring">                w
</span><span class="boring">            },
</span><span class="boring">            None =&gt; panic!(&quot;No more threads!&quot;),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn wait(&amp;self, w: Worker) {
</span><span class="boring">        w.receiver.recv().expect(&amp;format!(&quot;wait {} receive error&quot;, w.id));
</span><span class="boring">
</span><span class="boring">        let mut workers = self.threads.lock().unwrap();
</span><span class="boring">        workers.push(w);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn drain(&amp;self) {
</span><span class="boring">        let mut workers = self.threads.lock().unwrap();
</span><span class="boring">        while let Some(w) = workers.pop() {
</span><span class="boring">            w.sender.send(Task::Quit).expect(&amp;format!(&quot;send quit to {} failed&quot;, w.id));
</span><span class="boring">            w.thread.join().expect(&amp;format!(&quot;join with {} failed&quot;, w.id));
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn scoped&lt;'pool, 'scope, F, R&gt;(&amp;'pool self, f: F) -&gt; R
    where F: FnOnce(&amp;Scope&lt;'pool, 'scope&gt;) -&gt; R
    {
        let scope = Scope {
            pool: self,
            _marker: PhantomData,
        };
        f(&amp;scope)
    }
}

pub struct Scope&lt;'pool, 'scope&gt; {
    pool: &amp;'pool ThreadPool,
    // The 'scope needs to be invariant... it seems?
    _marker: PhantomData&lt;::std::cell::Cell&lt;&amp;'scope mut ()&gt;&gt;,
}

impl&lt;'pool, 'scope&gt; Scope&lt;'pool, 'scope&gt; {
    /* Execute a scoped job on the threadpool.
     *
     *The body of the closure will be sent to one of the internal threads
     */
    pub fn execute&lt;F&gt;(&amp;self, f: F) -&gt; Worker
    where F: FnOnce() + Send + 'scope {
        self.execute_(f)
    }

    fn execute_&lt;F&gt;(&amp;self, f: F) -&gt; Worker
    where F: FnOnce() + Send + 'scope {
        let b = unsafe {
            mem::transmute::&lt;Job&lt;'scope&gt;, Job&lt;'static&gt;&gt;(Box::new(f))
        };
        self.pool.execute(Task::Work(b))
    }
}

type Job&lt;'a&gt; = Box&lt;dyn FnOnce() + Send + 'a&gt;;

pub enum Task {
    Quit,
    Work(Job&lt;'static&gt;),
}
<span class="boring">
</span><span class="boring">pub struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    sender: mpsc::Sender&lt;Task&gt;,
</span><span class="boring">    receiver: mpsc::Receiver&lt;bool&gt;,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let (thread_sender, thread_receiver) = mpsc::channel(); 
</span><span class="boring">        let (mgr_sender, mgr_receiver) = mpsc::channel(); 
</span><span class="boring">        let thread = thread::spawn(move || {
</span><span class="boring">            loop {
</span><span class="boring">                let work: Task = thread_receiver.recv().unwrap();
</span><span class="boring">                match work {
</span><span class="boring">                    Task::Quit =&gt; {
</span><span class="boring">                        break;
</span><span class="boring">                    },
</span><span class="boring">                    Task::Work(job) =&gt; {
</span><span class="boring">                        job();
</span><span class="boring">                    },
</span><span class="boring">                }
</span><span class="boring">                mgr_sender.send(true).expect(&quot;failed manager send&quot;);
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, sender: thread_sender, receiver: mgr_receiver, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>The rest of the pool is more or less the same, <em>except</em>:</p>
<ul>
<li>lock <em>only</em> the vector of workers
<ul>
<li>only need to hold lock for <code>push</code>/<code>pop</code></li>
<li>all <code>&amp;mut self</code> methods become <code>&amp;self</code></li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::mem;
</span><span class="boring">use std::sync::{mpsc, Mutex};
</span><span class="boring">use std::marker::PhantomData;
</span><span class="boring">
</span>pub struct ThreadPool {
    threads: Mutex&lt;Vec&lt;Worker&gt;&gt;
}

impl ThreadPool {
    pub fn new(n: usize) -&gt; ThreadPool {
        let threads = Mutex::new(Vec::with_capacity(n));
        {
            let mut workers = threads.lock().unwrap();
            for i in 0..n {
                workers.push(Worker::new(i));
            }
        }
        ThreadPool { threads }
    }

    fn execute(&amp;self, job: Task) -&gt; Worker {
        let worker = {
            let mut workers = self.threads.lock().unwrap();
            workers.pop()
        };
        match worker {
            Some(w) =&gt; {
                w.sender.send(job).unwrap();
                w
            },
            None =&gt; panic!(&quot;No more threads!&quot;),
        }
    }

    pub fn wait(&amp;self, w: Worker) {
        w.receiver.recv().expect(&amp;format!(&quot;wait {} receive error&quot;, w.id));

        let mut workers = self.threads.lock().unwrap();
        workers.push(w);
    }

    pub fn drain(&amp;self) {
        let mut workers = self.threads.lock().unwrap();
        while let Some(w) = workers.pop() {
            w.sender.send(Task::Quit).expect(&amp;format!(&quot;send quit to {} failed&quot;, w.id));
            w.thread.join().expect(&amp;format!(&quot;join with {} failed&quot;, w.id));
        }
    }
<span class="boring">
</span><span class="boring">    pub fn scoped&lt;'pool, 'scope, F, R&gt;(&amp;'pool self, f: F) -&gt; R
</span><span class="boring">    where F: FnOnce(&amp;Scope&lt;'pool, 'scope&gt;) -&gt; R
</span><span class="boring">    {
</span><span class="boring">        let scope = Scope {
</span><span class="boring">            pool: self,
</span><span class="boring">            _marker: PhantomData,
</span><span class="boring">        };
</span><span class="boring">        f(&amp;scope)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Scope&lt;'pool, 'scope&gt; {
</span><span class="boring">    pool: &amp;'pool ThreadPool,
</span><span class="boring">    // The 'scope needs to be invariant... it seems?
</span><span class="boring">    _marker: PhantomData&lt;::std::cell::Cell&lt;&amp;'scope mut ()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'pool, 'scope&gt; Scope&lt;'pool, 'scope&gt; {
</span><span class="boring">    /* Execute a scoped job on the threadpool.
</span><span class="boring">     *
</span><span class="boring">     *The body of the closure will be sent to one of the internal threads
</span><span class="boring">     */
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F) -&gt; Worker
</span><span class="boring">    where F: FnOnce() + Send + 'scope {
</span><span class="boring">        self.execute_(f)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn execute_&lt;F&gt;(&amp;self, f: F) -&gt; Worker
</span><span class="boring">    where F: FnOnce() + Send + 'scope {
</span><span class="boring">        let b = unsafe {
</span><span class="boring">            mem::transmute::&lt;Job&lt;'scope&gt;, Job&lt;'static&gt;&gt;(Box::new(f))
</span><span class="boring">        };
</span><span class="boring">        self.pool.execute(Task::Work(b))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job&lt;'a&gt; = Box&lt;dyn FnOnce() + Send + 'a&gt;;
</span><span class="boring">
</span><span class="boring">pub enum Task {
</span><span class="boring">    Quit,
</span><span class="boring">    Work(Job&lt;'static&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    sender: mpsc::Sender&lt;Task&gt;,
</span><span class="boring">    receiver: mpsc::Receiver&lt;bool&gt;,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let (thread_sender, thread_receiver) = mpsc::channel(); 
</span><span class="boring">        let (mgr_sender, mgr_receiver) = mpsc::channel(); 
</span><span class="boring">        let thread = thread::spawn(move || {
</span><span class="boring">            loop {
</span><span class="boring">                let work: Task = thread_receiver.recv().unwrap();
</span><span class="boring">                match work {
</span><span class="boring">                    Task::Quit =&gt; {
</span><span class="boring">                        break;
</span><span class="boring">                    },
</span><span class="boring">                    Task::Work(job) =&gt; {
</span><span class="boring">                        job();
</span><span class="boring">                    },
</span><span class="boring">                }
</span><span class="boring">                mgr_sender.send(true).expect(&quot;failed manager send&quot;);
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, sender: thread_sender, receiver: mgr_receiver, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Use the <code>scoped</code> method to pass the data partitions to the thread pool workers:
Note that <code>THREAD_POOL</code> is now <code>Arc</code> vs <code>Mutex</code> - much cleaner!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use rand::Rng;
</span><span class="boring">use std::sync::atomic::{AtomicU32, Ordering};
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::time::Instant;
</span><span class="boring">
</span><span class="boring">mod tpool;
</span><span class="boring">
</span><span class="boring">use tpool::ThreadPool;
</span><span class="boring">use lazy_static::lazy_static;
</span><span class="boring">
</span><span class="boring">const MILLION: u32 = 256; 
</span><span class="boring">static PAR_SEQ_THRESHOLD: AtomicU32 = AtomicU32::new(32);
</span><span class="boring">
</span><span class="boring">static THREAD_COUNT: AtomicU32 = AtomicU32::new(0);
</span><span class="boring">
</span>lazy_static! {
    static ref THREAD_POOL: Arc&lt;ThreadPool&gt; = Arc::new(ThreadPool::new(128));
}

fn parallel_quicksort&lt;T: PartialOrd + std::marker::Send + std::marker::Sync&gt;(v: &amp;mut [T]) {
    let len = v.len();
    if len &lt;= 1 {
        return;
    }

    if len &lt;= PAR_SEQ_THRESHOLD.load(Ordering::SeqCst) as usize {
        quicksort(v);
        return;
    }

    let mid = partition(v);
    let (lo, hi) = v.split_at_mut(mid);

    THREAD_COUNT.fetch_add(2, Ordering::SeqCst);

    let pool = Arc::clone(&amp;THREAD_POOL);
    let w1 = pool.scoped(|s| {
        s.execute(move || { parallel_quicksort(lo); })
    });
    let w2 = pool.scoped(|s| {
        s.execute(move || { parallel_quicksort(hi); })
    });

    pool.wait(w1);
    pool.wait(w2);
}
<span class="boring">
</span><span class="boring">fn quicksort&lt;T: PartialOrd&gt;(v: &amp;mut [T]) {
</span><span class="boring">    if v.len() &lt;= 1 {
</span><span class="boring">        return;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let mid = partition(v);
</span><span class="boring">    let (lo, hi) = v.split_at_mut(mid);
</span><span class="boring">    quicksort(lo);
</span><span class="boring">    quicksort(hi);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn partition&lt;T: PartialOrd&gt;(v: &amp;mut [T]) -&gt; usize {
</span><span class="boring">    let hi = v.len() - 1;
</span><span class="boring">    let lo = 0;
</span><span class="boring">    let pivot = hi;
</span><span class="boring">
</span><span class="boring">    let mut i = 0;
</span><span class="boring">    for j in lo..hi {
</span><span class="boring">        if v[j] &lt;= v[pivot] {
</span><span class="boring">            v.swap(i, j);
</span><span class="boring">            i += 1;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    v.swap(i, pivot);
</span><span class="boring">    i
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn initialize_data(len: usize) -&gt; Vec&lt;u32&gt; {
</span><span class="boring">    let mut data = Vec::with_capacity(len);
</span><span class="boring">    let mut rng = rand::thread_rng();
</span><span class="boring">
</span><span class="boring">    data.resize(len, 0);
</span><span class="boring">    for i in 0..len {
</span><span class="boring">        data[i] = rng.gen_range(0..len).try_into().unwrap();
</span><span class="boring">    }
</span><span class="boring">    data
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn reinitialize_data(v: &amp;mut [u32]) {
</span><span class="boring">    let mut rng = rand::thread_rng();
</span><span class="boring">    let len = v.len();
</span><span class="boring">    for i in 0..len {
</span><span class="boring">        v[i] = rng.gen_range(0..len).try_into().unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn bench&lt;F: FnOnce(&amp;mut [u32])&gt;(sort: F, data: &amp;mut [u32]) -&gt; u64 {
</span><span class="boring">    reinitialize_data(data);
</span><span class="boring">
</span><span class="boring">    let start = Instant::now();
</span><span class="boring">    sort(data);
</span><span class="boring">    let elapsed = Instant::now() - start;
</span><span class="boring">
</span><span class="boring">    if !data.windows(2).all(|w| w[0] &lt;= w[1]) {
</span><span class="boring">        println!(&quot;sort failed!&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    u64::from(elapsed.subsec_micros()) + elapsed.as_secs()*1000000u64
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    // First argument is the vector length
</span><span class="boring">    let len = match args.get(1) {
</span><span class="boring">        Some(slen) =&gt; match slen.parse::&lt;usize&gt;() {
</span><span class="boring">            Ok(num) =&gt; num,
</span><span class="boring">            Err(e) =&gt; {
</span><span class="boring">                println!(&quot;ignoring bad length: {}&quot;, e);
</span><span class="boring">                MILLION as usize
</span><span class="boring">            }
</span><span class="boring">        },
</span><span class="boring">        None =&gt; MILLION as usize,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    // Second argument is the parallel/sequential threshold
</span><span class="boring">    match args.get(2) {
</span><span class="boring">        Some(val) =&gt; match val.parse::&lt;u32&gt;() {
</span><span class="boring">            Ok(t) =&gt; {
</span><span class="boring">                PAR_SEQ_THRESHOLD.store(t, Ordering::SeqCst);
</span><span class="boring">            },
</span><span class="boring">            Err(e) =&gt; println!(&quot;ignoring bad value: {}&quot;, e),
</span><span class="boring">        },
</span><span class="boring">        None =&gt; (),
</span><span class="boring">    };
</span><span class="boring">    println!(&quot;Using len {}, par/seq threshold {}&quot;, len, PAR_SEQ_THRESHOLD.load(Ordering::SeqCst));
</span><span class="boring">        
</span><span class="boring">    let mut data = initialize_data(len);
</span><span class="boring">
</span><span class="boring">    let mut par_mean: f64 = 0.0;
</span><span class="boring">    for run in 0..10 {
</span><span class="boring">        let elapsed = bench(parallel_quicksort, &amp;mut data);
</span><span class="boring">        let tcount = THREAD_COUNT.swap(0, Ordering::SeqCst);
</span><span class="boring">        println!(&quot;parallel {}: {} usec, {} threads&quot;, run, elapsed, tcount);
</span><span class="boring">        par_mean += elapsed as f64;
</span><span class="boring">    }
</span><span class="boring">    par_mean /= 10.0;
</span><span class="boring">    println!(&quot;parallel mean: {} usec&quot;, par_mean);
</span><span class="boring">
</span><span class="boring">    let mut seq_mean: f64 = 0.0;
</span><span class="boring">    for run in 0..10 {
</span><span class="boring">        let elapsed = bench(quicksort, &amp;mut data);
</span><span class="boring">        println!(&quot;sequential {}: {}&quot;, run, elapsed);
</span><span class="boring">        seq_mean += elapsed as f64;
</span><span class="boring">    }
</span><span class="boring">    seq_mean /= 10.0;
</span><span class="boring">    println!(&quot;sequential mean: {} usec&quot;, seq_mean);
</span><span class="boring">    
</span><span class="boring">    println!(&quot;speedup: {}&quot;, seq_mean/par_mean);
</span><span class="boring">
</span><span class="boring">    let pool = Arc::clone(&amp;THREAD_POOL);
</span><span class="boring">    pool.drain();
</span><span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
