# Pinning

Unlike threads, `async` functions can accept non-`'static` references, which
results in a `Future` that is bounded by the lifetime of the argument:

```rust
// This function:
async fn foo(x: &u8) -> u8 { *x }

// Is equivalent to this function:
fn foo_expanded<'a>(x: &'a u8) -> impl Future<Output = u8> + 'a {
    async move { *x }
}
```

This means that the data must live long enough for the future to `.await` it.

_Pinning_ is used to prevent a pointer from changing while the future awaits its completion.

### Why Pin?

The problem comes down to self-referential types (e.g. lists):

```rust
{{#rustdoc_include ../listings/pin/src/main.rs:test}}
```

You can see that `self.b` is set to point within itself, `&self.a`

What happens if we swap `test1` with `test2`, which moves the pointers?

```rust
{{#rustdoc_include ../listings/pin/src/main.rs:swap}}
```

**Fig 1: Before and after swap**
![swap_problem](./img/swap_problem.jpg)

### Using Pin

To see how pinning helps, first make our structure `!Unpin` using
[std::marker::PhantomPinned](https://doc.rust-lang.org/std/marker/struct.PhantomPinned.html)

```rust
{{#rustdoc_include ../listings/unpin/src/main.rs:pin}}
```

Then use the [pin-utils](https://docs.rs/pin-utils/latest/pin_utils) crate to
`Pin` our stack values:

```rust
{{#rustdoc_include ../listings/unpin/src/main.rs:swap}}
```

You could also pin with `Box`:

```rust
use pin_utils::pin_mut; // `pin_utils` is a handy crate available on crates.io

// A function which takes a `Future` that implements `Unpin`.
fn execute_unpin_future(x: impl Future<Output = ()> + Unpin) { /* ... */ }

let fut = async { /* ... */ };
execute_unpin_future(fut); // Error: `fut` does not implement `Unpin` trait

// Pinning with `Box`:
let fut = async { /* ... */ };
let fut = Box::pin(fut);
execute_unpin_future(fut); // OK

// Pinning with `pin_mut!`:
let fut = async { /* ... */ };
pin_mut!(fut);
execute_unpin_future(fut); // OK
```

### Summary

1. If a type implements `Unpin`, then `Pin<'a, T>` is equivalent to `&'a mut T`. i.e. `Unpin` means it's OK for this type to be moved even when pinned.
1. Most types, including standard library types, implement `Unpin`.
1. `Futures` generated by async/await do *not* implement `Unpin`.
1. You can pin both stack (`pin_mut!`) and heap data (`Box::pin`).
1. Some pins require `unsafe`. You must follow the rules of the _pin contract_ for your code to work.
